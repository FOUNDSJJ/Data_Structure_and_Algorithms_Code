大二_数据结构A_作业2




T1 两数之和



#include <iostream>
#include <fstream>
#include <vector>

using namespace std;

int total_of_num = 0;

class solution {
public:
	vector<int> twoSum(vector<int>& nums, int target) {
		int x = 0;
		for (int i = 0; i < total_of_num - 1; i++) {
			for (int j = i + 1; j < total_of_num; j++) {
				if ((nums[i] + nums[j]) == target) {
					cout << i << " " << j << endl;
					x = 1;
					break;
				}
			}
		}
		if (x == 0) {
			cout << "-1" << " " << "-1" << endl;
		}
		return nums;
	}
};


int main() {
	ifstream ifs("in.txt");
	int x;
	vector<int> nums;
	while (ifs >> x) {
		nums.push_back(x);
		total_of_num++;
	}
	solution a;
	total_of_num--;
	a.twoSum(nums, nums[total_of_num]);
	ifs.close();
	return 0;
}





T2 链表重排



#include <iostream>
#include <fstream>

using namespace std;

class Node {
public:
	int val;
	Node* next;
	Node();
	Node(int v);
};

Node::Node() {
	next = nullptr;
}

Node::Node(int v) {
	val = v;
	next = nullptr;
}

class list {
public:
	list();
	void headinsert(int);
	void tailinsert(int);
	void betweeninsert(int, int);
	void Delete(int);
	Node* getval(int);
	void showlist();
	void reorderList();
	void copylist(list);
private:
	Node* head;
	int count;
};

list::list() {
	head = new Node();
	count = 0;
}

void list::headinsert(int v) {
	Node* s = new Node(v);
	Node* p = head->next;
	if (count == 0) {
		count++;
		head->next = s;
		return;
	}
	else {
		count++;
		s->next = p;
		head->next = s;
		return;
	}
}

void list::tailinsert(int v) {
	Node* s = new Node(v);
	Node* p = head;
	while (p->next != nullptr) {
		p = p->next;
	}
	p->next = s;
	count++;
	return;
}

void list::betweeninsert(int i, int v) {
	Node* s = new Node(v);
	if (i<0 || i>count) {
		cout << "插入的位置不在链表长度以内，插入失败" << endl;
		return;
	}
	else {
		if (i == 0) {
			headinsert(v);
			return;
		}
		else {
			if (i == count) {
				tailinsert(v);
				return;
			}
			else {
				count++;
				Node* p = head;
				for (int j = 0; j < i; j++) {
					p = p->next;
				}
				s->next = p->next;
				p->next = s;
				return;
			}
		}
	}
}

void list::Delete(int i) {
	Node* p = head;
	if (i < 0 || i >= count) {
		cout << "链表上不存在要删除的元素" << endl;
		return;
	}
	else {
		count--;
		for (int j = 0; j < i; j++) {
			p = p->next;
		}
		Node* q = p->next;
		p->next = q->next;
		delete q;
		return;
	}
}

Node* list::getval(int i) {
	if (i < 0 || i >= count) {
		//cout << "链表上不存在该元素" << endl;
		return nullptr;
	}
	else {
		Node* p = head->next;
		for (int j = 0; j < i; j++) {
			p = p->next;
		}
		//cout << p->val << endl;
		return p;
	}
}

void list::showlist() {
	Node* p = head->next;
	while (p != nullptr) {
		if (p->next == nullptr)
			cout << p->val;
		else {
			cout << p->val << " ";
		}
		p = p->next;
	}
	//cout << "nullptr";
	return;
}

void list::copylist(list t) {
	Node* s = head->next;
	head->next = t.head->next;
	t.head->next = s;
}

void list::reorderList() {
	list templist;
	int a = count % 2;
	if (a == 0) {
		for (int i = 0; i < count / 2; i++) {
			Node* prior = getval(i);
			Node* next = getval(count - i - 1);
			templist.tailinsert(prior->val);
			templist.tailinsert(next->val);
		}
	}
	if (a == 1) {
		for (int i = 0; i < (count-1) / 2; i++) {
			Node* prior = getval(i);
			Node* next = getval(count - i - 1);
			templist.tailinsert(prior->val);
			templist.tailinsert(next->val);
		}
		Node* q = getval((count - 1)/2);
		int v = q->val;
		templist.tailinsert(v);
	}
	copylist(templist);
}

int main() {
	list a;
	fstream ifs("in.txt");
	int v;
	while (ifs >> v) {
		a.tailinsert(v);
	}
	a.reorderList();
	a.showlist();
	return 0;
}





T3 顺序表元素划分








T4 集合并集运算



#include <iostream>
#include <fstream>

using namespace std;

void Arrange(int*& Set, int num) {
	for (int i = 1; i < num; i++) {
		for (int j = 0; j < num - i; j++) {
			if (Set[j + 1] < Set[j]) {
				int temp = Set[j + 1];
				Set[j + 1] = Set[j];
				Set[j] = temp;
			}
		}
	}
}

void Arrange_TwoSet(int*& A, int*& B, int num_A, int num_B, int*& result) {
	Arrange(A, num_A);
	Arrange(B, num_B);
	int m = 0, n = 0;
	int i = 1;
	for (; m < num_A && n < num_B;) {
		if (A[m] < B[n]) {
			result[i] = A[m];
			m++;
		}
		else {
			if (B[n] < A[m]) {
				result[i] = B[n];
				n++;
			}
			else {
				result[i] = A[m];
				m++;
				n++;
			}
		}
		i++;
	}
	while (m < num_A) {
		result[i] = A[m];
		i++;
		m++;
	}
	while (n < num_B) {
		result[i] = B[n];
		i++;
		n++;
	}
	result[0] = i - 1;
}

int main() {
	ifstream ifs("in.txt");
	int num_A, num_B;
	ifs >> num_A >> num_B;
	if (num_A < 0 && num_B < 0)
		return 0;
	int* A = new int[num_A];
	int* B = new int[num_B];
	int temp;
	for (int i = 0; i < num_A + num_B; i++) {
		ifs >> temp;
		if (i < num_A)
			A[i] = temp;
		else
			B[i - num_A] = temp;
	}
	ifs.close();
	int* result = new int[num_A + num_B + 1];
	Arrange_TwoSet(A, B, num_A, num_B, result);
	for (int i = 1; i <= result[0]; i++)
		cout << result[i] << " ";
	return 0;
}